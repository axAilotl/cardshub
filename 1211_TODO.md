### Critical Issues (Must Fix)

*   **Ineffective Rate Limiting for Serverless/Edge:**
    The `src/lib/rate-limit.ts` implementation uses an in-memory `Map` (`const buckets = new Map()`).
    *   **Why it's critical:** Your project uses Cloudflare/Next.js (Edge/Serverless). Each request is likely handled by a different isolated instance. The `buckets` Map is **not shared** between requests. An attacker can hit your API thousands of times, and each request might hit a fresh "bucket," bypassing the limit entirely.
    *   **Fix:** Use an external store like **Cloudflare KV**, **Redis (Upstash)**, or **D1** to store rate limit counters.
    *   **Example (Cloudflare KV concept):**
        ```typescript
        // src/lib/rate-limit.ts
        export async function rateLimit(key: string, limit: number, windowMs: number) {
           // Use KV binding or generic cache interface
           const count = await kv.get(key);
           if (count > limit) return { allowed: false };
           await kv.put(key, count + 1, { expirationTtl: windowMs / 1000 });
           return { allowed: true };
        }
        ```

*   **Uploads API fails open on Cloudflare/R2:**
    In `src/app/api/uploads/[...path]/route.ts`, the Cloudflare branch fetches objects directly from R2 with no path validation and no visibility enforcement when `uploads` metadata is missing.
    *   **Why it's critical:** Any R2 object (even "private" or unlisted) can be read if the attacker guesses the key. Requests without metadata default to public caching headers, so missing metadata becomes a silent leak.
    *   **Fix:** Fail closed when `getUploadByPath` returns null; reuse `safeResolveUploadPath`-style validation for R2 keys; require metadata visibility checks (owner/admin for `private`, token for `unlisted`) before returning bytes.
    *   **Example:**
        ```typescript
        const meta = await getUploadByPath(pathKey);
        if (!meta) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
        if (meta.visibility === 'private' && !isOwner(session, meta)) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
        if (meta.visibility === 'unlisted' && !validToken(token, meta)) return NextResponse.json({ error: 'Invalid token' }, { status: 403 });
        ```

*   **Client-provided upload metadata is trusted:**
    In `src/app/api/cards/route.ts` the POST handler accepts `metadata` and `contentHash` from the client and persists them without recomputation.
    *   **Why it's critical:** Attackers can lie about token counts, NSFW flags, embedded image counts, and hashes, bypassing server-side limits or poisoning search filters. Large `cardData` strings can be stored unchecked.
    *   **Fix:** Always re-parse and re-count server-side; recompute `contentHash` on the server; ignore client-supplied token/metadata unless verified against the parsed card; bound `cardData` size and strip untrusted fields.

### Warnings (Should Fix)

*   **Feed Query Performance (Database Indexing):**
    In `src/app/api/feed/route.ts`, the trending query sorts by a calculation:
    `ORDER BY (c.upvotes + c.downloads_count * 0.5) DESC`
    *   **Why it's a warning:** Standard indexes on `upvotes` or `downloads_count` (which you have) cannot be used for this calculation. The database must perform a "full table scan" and calculate this value for *every* public card before sorting. As your database grows, this endpoint will become extremely slow.
    *   **Fix:** Add a generated column and index it in `src/lib/db/schema.sql`.
    *   **Example:**
        ```sql
        -- Add to cards table
        -- SQLite generated column
        trending_score GENERATED ALWAYS AS (upvotes + (downloads_count * 0.5)) VIRTUAL;
        
        -- Create index on the generated column
        CREATE INDEX idx_cards_trending ON cards(trending_score DESC);
        ```

*   **Stateful Auth on Edge:**
    `src/lib/auth/index.ts` fetches the session from the database on every request (`SELECT ... FROM sessions WHERE id = ?`).
    *   **Why it's a warning:** On Cloudflare D1/Edge, this adds a database round-trip latency to *every single API call* and page load.
    *   **Fix:** Consider switching to **Stateless JWTs** (using `jose`) for session tokens, verifying the signature locally without a DB lookup. Only check the DB for critical actions (password changes, strict admin gates).

*   **Repository includes live session cookie:**
    `cookies.txt` (untracked) contains a session value and is not ignored by `.gitignore`.
    *   **Why it's a warning:** Easy to commit by accident, leaking auth tokens.
    *   **Fix:** Add `cookies.txt` to `.gitignore` or delete the file locally.

### Suggestions (Consider Improving)

*   **Search Param Validation:**
    In `src/app/api/feed/route.ts`, `searchParams` are parsed manually (`parseInt(...)`).
    *   **Suggestion:** Use your existing **Zod** library to validate incoming query parameters. It's cleaner and safer.
    *   **Example:**
        ```typescript
        const FeedParams = z.object({
          page: z.coerce.number().min(1).default(1),
          limit: z.coerce.number().min(1).max(50).default(24),
        });
        const { page, limit } = FeedParams.parse(Object.fromEntries(searchParams));
        ```

*   **Sequential Await in Feed Logic:**
    The feed route awaits database queries one by one:
    `await blockedTags...` then `await followedUserCards...` then `await followedTagCards...`
    *   **Suggestion:** Run independent queries in parallel using `Promise.all` to reduce response time.
    *   **Example:**
        ```typescript
        const [followedUserCards, followedTagCards, trendingCards] = await Promise.all([
          db.prepare(...).all(userId),
          db.prepare(...).all(userId),
          db.prepare(...).all()
        ]);
        ```

### Component Trees & Structure
The component structure in `src/components` is logical and modular (`cards/`, `feed/`, `ui/`). The separation of UI primitives (badges, buttons) from feature components (card-grid) is excellent for maintainability.

### Documentation Updates
*   **Update `README.md` or `PLAN.md`:** Mention the requirement for a persistent store (KV/Redis) for rate limiting if deploying to production.
*   **Schema:** If you implement the trending index fix, update `schema.sql` to include the generated column.
